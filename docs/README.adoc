= OpenShift-Ansible Integration Lab

== 0 Introduction

=== 0.1 Usecase

Today we are building a WIDGET inventory tracking system. It comprises of a simple
data driven application backed by MySQL. We will be deploying the application on OpenShift
and the database server on a RHEL virtual machine. 

=== 0.2 Ansible and OpenShift

The goal of this lab is to show how the [OpenShift Container Platform](https://docs.openshift.com/container-platform/latest/getting_started/index.html)
and [Ansible Automation](https://www.ansible.com/resources/get-started) can build on
each other to increase innovation and accelerate delivery.

First we'll introduce how Ansible can be used to automate provisioning and configuration
of application dependencies. Then we'll look at how we can leverage Ansible for application
configuration within OpenShift as part of a pipeline. Finally, we will dig into how the
[OpenShift Ansible Broker](https://docs.openshift.com/container-platform/3.11/architecture/service_catalog/ansible_service_broker.html)
adds self-service automation to the platform.

== 1 Install MySQL Server with Ansible Engine

=== 1.1 Introduction to Ansible

=== 1.2 Review Playbook

First you'll need to connect to your lab. To do that you'll need to ssh using your student account to the Master Node
for your student account. The command will look like this:

```
$ ssh -o 'StrictHostKeyChecking no' student1@ec2-18-234-37-92.compute-1.amazonaws.com
```

Alternatively you can skip the `StrictHostKeyChecking` option and just accept host key check prompt.

Once on the Master Node, you'll need to set up shop. First we're gonna install `git` so we can pull down the lab source
code.

```
$ sudo yum install -y git
```

Next we're gonna clone the lab:

```
$ git clone https://github.com/srang/rh-openshift-ansible-broker-lab.git
```

Now for convenience let's define an environment variable on our Master Node that says where the source code is:

```
$ echo export GIT_BASE="$(pwd)/rh-openshift-ansible-broker-lab" >> ~/.bashrc
$ source ~/.bashrc
$ cd $GIT_BASE
```

Finally, we need to make sure we're looking at the right branch of the lab (we're in section 1) so run:

```
$ git checkout section-1
```

Go into the `database-provision-playbook` directory and look around. This is a good opportunity to install your favorite
terminal-based editor. Adventurous developers could also fork the lab repository, clone it locally (to your personal
machine), edit code in an IDE, and update git remotes to pull from a fork but for the purpose of this lab we will assume
we're working directly on the Master Node.

=== 1.3 Provision MySQL server on VM

Most of this playbook is pre-configured for you, take a look at `database-provision.yml`. It is installing MariaDB (an
opensource fork of MySQL), configuring a database on the server, and adding a user for that database. Let's try running
it!

In order to run this playbook in your environment, you'll need to update the `hosts` file in the inventory folder.
The username needs to match *your* student account or you will get authentication errors.

```
[all:vars]
ansible_user=student1 <- This is the line that needs to be changed
```

Additionally, you'll need to update `hosts` with the hosts in *your* lab. Update the `[db-server]` section with your
database node hostname.

```
[db-server]
ec2-54-161-113-184.compute-1.amazonaws.com <- This should match your environments Database Node
```

Once you've made these updates, you're ready to run the playbook.

```
$ ansible-playbook -vv database-playbook.yml -i inventory/
```

Let's connect to the database and see what's there

```
$ mysql --user=widget --password=widget01 widgettest
```

We should see that our database is _completely_ empty. But we can fix that pretty easily. We're going to jump ahead a
little bit and "deploy" our widget factory in our workspace and connect to the database there. In order to do that,
we're also going to need to build and run our application:

```
$ cd $GIT_BASE/widget-factory
$ sudo yum install -y rh-maven35 --enablerepo=rhel-server-rhscl-7-rpms
$ scl enable rh-maven35 bash
$ mvn clean install -Pdeploy
```

That was a lot all at once but basically what we did was exactly what we said -- install the build tool for our app,
then build the app.

=== 1.4 Run Canary Application

== 2 Deploy Application

`$ oc new-project widget-factory`

=== 2.1 Auto-deploy Jenkins (Template Service Broker)

https://docs.openshift.com/container-platform/3.10/install_config/configuring_pipeline_execution.html

=== 2.2 Configure `widget-jenkins-agent`

```
$ git checkout section-2
$ cd ../widget-jenkins-agent
$ oc process -f widget-pipeline.yml -p section-2 | oc apply -f-
```

=== 2.3 Review Application

```
$ oc secrets new generic mysql --from-generic=username=dummy --from-generic=password=dummy
```

=== 2.4 Ansible-Applier

=== 2.5 Deploy Application

== 3 Connect Application to MySQL

=== 3.1 Review Legacy Solution

=== 3.2 Automation Service Broker

=== 3.3 Build an APB

```
$ git checkout section-3
$ cd ../database-provision-apb

...

$ oc new-build --binary=true --name database-provision-apb
$ oc policy add-role-to-user system:image-builder system:serviceaccount:widget-factory:builder -n openshift
$ oc patch bc/database-provision-apb -p '{"spec": {"output":{"to": {"namespace": "openshift" } } } }'

...

$ apb bundle prepare
$ oc start-build --follow --from-dir . database-provision-apb
$ apb broker bootstrap
```

=== 3.4 Provision Database and Credentials

=== 3.5 Update Application to Use Bindings